/*
 * File: TestBenchWriter.cs
 * 
 * Author: Andrew Danowitz
 * Harvey Mudd College, Claremont, CA 91711
 * Sketchers 2007.
 * 
 * Use at your own risk.  This code is not maintained and not guaranteed to work.
 * We take no responsibility for any harm this code may cause.
 */

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using Pins;



namespace VerilogWriter
{
    /// <summary>
    /// This class is capable of generating Verilog Self-Checking Testbenches given
    /// members of the module class
    /// </summary>
    public class TestBenchWriter
    {
        //Name of the module
        private String moduleName;

        //Module filePath
        private String filePath;

        //Names of circuit inputs and outputs
        private PinList inputs;
        private PinList outputs;

        #region Constructors

        /// <summary>
        /// Constructor for the TestBenchWriter class
        /// </summary>
        /// <param name="filePath">String containing the file path
        /// where the testbench should be saved</param>
        /// <param name="mod">Module containing the circuit that the testbench will be generated for</param>
        public TestBenchWriter(String filePath, Module mod)
        {
            //Class assignments
            this.filePath = filePath;
            this.inputs = new PinList(mod.inputPins);
            this.outputs = new PinList(mod.outputPins);
            this.moduleName = mod.moduleName;
        }

        #endregion

        /// <summary>
        /// Writes the testbench for the TestBenchWriter 
        /// </summary>
        public void writeBench()
        {
            String dir = this.filePath;
            
            headerWrite(dir);
            int tv_count = instantiate(dir);
            initTest(dir);
            test(dir, tv_count);
            
            //Writes the code to test for discrepancies between any actual outputs and their
            //expected output
            
        }

        /// <summary>
        /// Writes out the header of the testbench
        /// </summary>
        /// <param name="dir">String containing directory path of where the circuit should
        /// be saved</param>
        private void headerWrite(String dir)
        {
            
            //The header of the testbench file
            String header = "`timescale 1ns/1ps \n\n" +
                "//////////////////////////////////////////////////////////////////////\n" +
                "//This testbench was automatically generated by \n" +
                "//the TestBenchWriter class of VerilogWriter\n" +
                "//////////////////////////////////////////////////////////////////////\n\n";

            //Sets the file to either create a new testbench or overwrite the old
            FileStream fs = new FileStream(dir + "\\test.v", FileMode.Create, FileAccess.Write);
            TextWriter tw = new StreamWriter(fs);
            tw.Write(header);
            tw.Close();
            fs.Close();
        }

        /// <summary>
        /// Writes the testbench code that instantiates the module and writes out the 
        /// inputs and outputs
        /// </summary>
        /// <param name="dir">String containing directory path of where the circuit should
        /// be saved</param>
        /// <returns>int containing the required width of the testvectors</returns>
        private int instantiate(String dir)
        {
            //Sets the file writer to append mode
            FileStream fs = new FileStream(dir + "\\test.v", FileMode.Append, FileAccess.Write);
            TextWriter tw = new StreamWriter(fs);

            //puts the inputs into a temp value so that once the clock is removed, it doesn't
            //remove it from the class object
            PinList tempInputs = new PinList();

            tempInputs.AddRange(inputs.Pins);

            tw.Write("module test; \n\n\t//inputs\n");

            int i = 0;

            //Gets the name of the clock variable
            Pin clkVar = tempInputs.clk_var();

            //Console.WriteLine(clkVar);
            //Removes the clock variable from the inputs and insizes
            tempInputs.clk_rm(clkVar);

            tw.Write("\treg " + clkVar.PinName + ";\n");

            //Writes out the module inputs
            foreach (Pin datain in tempInputs.Pins)
            {

                if (datain.bussize > 1)
                {
                    tw.Write("\treg [");
                    tw.Write(datain.bussize - 1);
                    tw.Write(":0] " + datain.PinName + ";\n");
                }
                else
                {
                    tw.Write("\treg " + datain.PinName + ";\n");
                }
            }

            tw.Write("\n\t//expected results\n");

            //Writes the expected module outputs
            foreach (Pin dataout in outputs.Pins)
            {
                if (dataout.bussize > 1)
                {
                    tw.Write("\treg [");
                    tw.Write(dataout.bussize - 1);
                    tw.Write(":0] " + dataout.PinName + "Expected;\n");
                }
                else
                {
                    tw.Write("\treg " + dataout.PinName + "Expected;\n");
                }
            }

            tw.Write("\n\t//outputs\n");

            //Writes the module outputs
            foreach (Pin dataout in outputs.Pins)
            {
                if (dataout.bussize > 1)
                {
                    tw.Write("\twire [");
                    tw.Write(dataout.bussize - 1);
                    tw.Write(":0] " + dataout.PinName + ";\n");
                }
                else
                {
                    tw.Write("\twire " + dataout.PinName + ";\n");
                }
            }

            tw.Write("\tinteger error, ch;");

            int tv_count = 0;

            //Adds the bus sizes of each input and output to generate the width of the
            //expected test vectors
            foreach (Pin instance in tempInputs.Pins)
                tv_count += instance.bussize;
            foreach (Pin instance in outputs.Pins)
                tv_count += instance.bussize;

            tw.Write("\n\n\n\treg[31:0] vectornum, errors;\n");
            tw.Write("\n\treg[" + (tv_count - 1) + ":0] testvectors[10000:0];\n");

            tw.Write("\n\t//Instantiate the Unit Under Test (UUT)\n\t"
                + moduleName + " uut(\n");


            i = 0;

            //System.Windows.Forms.MessageBox.Show(clkVar.PinName + !clkVar.PinName.Equals("auto_clk"));
            //Lists the inputs and outputs for module instantiation
            if (!clkVar.PinName.Equals("auto_clock"))
                tw.Write("\t\t." + clkVar.PinName + "(" + clkVar.PinName + ")");

            foreach (Pin datain in tempInputs.Pins)
            {
                if ((clkVar.PinName.Equals("auto_clock")) && (i == 0))
                    tw.Write("\t\t." + datain.PinName + "(" + datain.PinName + ")");
                else
                    tw.Write(",\n\t\t." + datain.PinName + "(" + datain.PinName + ")");
                i++;
            }

            foreach (Pin dataout in outputs.Pins)
            {
                tw.Write(",\n\t\t." + dataout.PinName + "(" + dataout.PinName + ")");
            }
            
            tw.Close();
            fs.Close(); 

            return tv_count;
        }

        /// <summary>
        /// Writes the initialization code for reading in the test vectors
        /// </summary>
        /// <param name="dir">String containing directory path of where the circuit should
        /// be saved</param>
        private void initTest(String dir)
        {
            //Sets the file writer to append mode
            FileStream fs = new FileStream(dir + "\\test.v", FileMode.Append, FileAccess.Write);
            TextWriter tw = new StreamWriter(fs);

            int i;

            PinList tempInputs = new PinList();

            tempInputs.AddRange(inputs.Pins);

            Pin clkVar = tempInputs.clk_var();
            tempInputs.clk_rm(clkVar);

            tw.Write("\n\t);\n\n");
            tw.Write("\talways\n\t\tbegin\n\t\t\t" +
                clkVar.PinName + "=1; #5; " + clkVar.PinName + "=0; #5;\n\t\tend\n");
            tw.Write("\n\tinitial\n\t\tbegin\n" +
                "\t\t\terror = $fopen(\"error.log\");\n" +
                "\t\t\tif(error==0) $stop(2);\n" +
                "\t\t\tch = error|1;\n" +
                "\t\t\t$readmemb(\"testVect.tv\", testvectors);\n" +
                "\t\t\tvectornum=0; errors=0;\n\t\tend\n");
            tw.Write("\n\talways @ (posedge " + clkVar.PinName + ")\n\t\tbegin\n" +
                "\t\t\t#1; {");

            i = 0;

            //Writes out the inputs for testvector assignment
            foreach (Pin datain in tempInputs.Pins)
            {
                if (datain.bussize > 1)
                {
                    if (i == 0)
                    {
                        tw.Write(datain.PinName + "[" +
                            (datain.bussize - 1) + ":0]");
                    }
                    else
                    {
                        tw.Write(", " + datain.PinName + "[" +
                            (datain.bussize - 1) + ":0]");
                    }
                }

                else
                {
                    if (i == 0)
                    {
                        tw.Write(datain.PinName);
                    }
                    else
                    {
                        tw.Write(", " + datain.PinName);
                    }
                }
                i++;
            }

            //Writes out the expected outputs for testvector assignment
            foreach (Pin dataout in outputs.Pins)
            {
                if (dataout.bussize > 1)
                {
                    tw.Write(", " + dataout.PinName + "Expected[" +
                            (dataout.bussize - 1) + ":0]");
                }
                else
                {
                    tw.Write(", " + dataout.PinName + "Expected");
                }
            }

            tw.Write("}=\n\t\t\ttestvectors[vectornum];\n\t\tend\n");

            tw.Write("\n\talways @ (negedge " + clkVar.PinName + ")\n\t\tbegin\n");

            tw.Close();
            fs.Close();
        }

        /// <summary>
        /// Writes the verilog code that runs the actual tests
        /// </summary>
        /// <param name="dir">String containing directory path of where the circuit should
        /// be saved</param>
        /// <param name="tv_count">Int containing the width of required test vectors</param>
        private void test(String dir, int tv_count)
        {
            //Sets the file writer to append mode
            FileStream fs = new FileStream(dir + "\\test.v", FileMode.Append, FileAccess.Write);
            TextWriter tw = new StreamWriter(fs);

            PinList tempInputs = new PinList();
            inputs.clk_rm();
            tempInputs.AddRange(inputs.Pins);

            foreach (Pin dataout in outputs.Pins)
            {
                if (dataout.bussize > 1)
                {
                    tw.Write("\t\t\tif (" + dataout.PinName + "[" + (dataout.bussize - 1) + ":0] !==" +
                        dataout + "Expected[" + (dataout.bussize - 1) + ":0])begin\n");
                    tw.Write("\t\t\t\t$display(\"Error:\");\n");
                }
                else
                {
                    tw.Write("\t\t\tif (" + dataout.PinName + "!==" +
                        dataout.PinName + "Expected" + ")begin\n");
                    tw.Write("\t\t\t\t$display(\"Error:\");\n");
                }
                //Lists all of the inputs
                foreach (Pin datain in tempInputs.Pins)
                {
                    tw.Write("\t\t\t\t$fdisplay(ch, \"" + datain.PinName + "=%b\", " + datain.PinName + ");\n");
                }

                tw.Write("\t\t\t\t$fdisplay(ch, \"Expected: " + dataout.PinName + "=%b (%b expected)\",\n" +
                    "\t\t\t\t\t\t" + dataout.PinName + ", " + dataout.PinName + "Expected);\n");
                tw.Write("\t\t\t\terrors = errors + 1;\n\t\t\tend\n\n");
            }

            tw.Write("\t\t\tvectornum=vectornum + 1;\n");
            tw.Write("\t\t\tif( testvectors[vectornum]===" + tv_count + "'bx)begin\n" +
                "\t\t\t\t$display(\"%d tests completed with %d errors\",\n" +
                "\t\t\t\t\t\tvectornum, errors);\n" +
                "\t\t\t\t$fclose(error);\n" +
                "\t\t\t\t$finish;\n\t\t\tend\n\t\tend\n\nendmodule");

            //Closes the textwriter and the filestream
            tw.Close();
            fs.Close();
        }
    }
}

